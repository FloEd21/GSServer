Problems occur at times with autohoming, where the mount slews the wrong way.

Home is detected by a semicircular blade mounted to the output axle
blocking/clearing an opto sensor as the axle rotates.
The disk is set up such that this trip point occurs when the CW bar is
vertically down and the DEC puck is pointing at the pole.
The firmware has a "reset" function which reads if the sensor
is blocked or clear, and it sets a variable to x000000 or xFFFFFF accordingly.
As the axle rotates, the system watches for the sensor to change state
at which point the variable gets set to the real microstep count.
The only problem is there appears to be a deadband around the trip point
where doing the reset can actually set the variable incorrectly.
The value assigned to this variable after reset is what determines
which way the mount slews to find home, and hence can cause "runaways".
Sooooo, how to code for it is what we are exploring.
We will only look at the case where the first reset returns x000000
( which means ( in theory ) we must slew CCW ( +ve ) to find home  ).
We do a series of short gotos of a set length to see if we can find home.
We use a "goto" vs a "slew", as we can control how far it goes,
and a loss of comms etc wont affect the ability for it to stop.

In the attached diag are the 6 possible situations
1) Occurs if you start and stop on the same side of home ( and outside the deadband )
2) This case is similar to 1, but we stopped in the deadband and hence
   "may" get different answers after doing a reset.
3) In this case, we also stop in the deadband, but we also get a detection
   of home, hence can ignore the start and end conditions.
4) In this case, we start and finish on either side of home and outside
   the deadband. We also get a clean detection of home.
5) In this case, we start in the deadband ( with a correct reset )
   and thus go in the correct direction and hence detect home.
7) In this case, we start in the deadband, but using a wrong reset value
   and hence we slew the wrong way. <<< this is what we think causes runaways

Thus, looking at the diag, 3a, 3b, 4 and 5 all detect home
and as such we are done for stage 1 of home detection.
Options 1 and 2a both start and stop with x000000 ( ie no home detected )
and hence we know we must be going the correct direction, so keep going.
Options 2b and 7 both give the same start and stop data after reset
ie after the second reset, the data has changed from x000000 to xFFFFFF,
but no home detection has taken place. This can only occur
if we started or stopped in the deadzone, and the reset var was wrong.
Sooooo, how to deal with it, as both "look" the same.
In 2b, we know if we immediately do a second slew, we MUST cross home.
In 7, if we do the same process, we wont hit home :-),
As such, for 2b or 7 all we do is a second goto in the same direction as the first.
If it detects home, we are done.
If not, we must reverse direction and restart the full process.

Once home is crudely detected via this mechanism, we need to ensure that we
can re find home from a set direction and at a set speed,
to remove any lash effects and speed related hysteresis.
As such, after Home is found above, i
1) do a goto to a point 1 deg CW (-ve) from home and reset the home variable
2) do a goto to a point 1 deg CCW from home and log the true home
3) do a goto to a point 1 deg CW from true home
4) do a goto to HOME

This always results in home being detected from a set direction at a set speed
and leaves all the gears preloaded
ie we should get consistent results

Only thing now is to run multiple tests from different locations
and on different mounts to prove the logic works.

As a beltsnbraces test, i limit the gotos i use to 5 deg,
as this means it can never get up to a dangerous speed,
and by using gotos, no stop command is required.
Thus, if you start a long way from home, it can take time
to get back.
Also, as a second backup, if the mount slews over 60deg without finding home,
it will pause and ask the user to confirm all is well,
vs just crunch into the hardstops in RA or twist the DEC up.
This can be refined later, but its currently how it works for testing.










